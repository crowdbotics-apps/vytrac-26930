import pytzfrom django.conf import settingsfrom django.contrib.auth.base_user import AbstractBaseUser, BaseUserManagerfrom django.contrib.auth.models import Permissionfrom django.contrib.auth.models import User, AbstractUser, PermissionsMixinfrom django.core.validators import RegexValidatorfrom django.db import modelsfrom safedelete import SOFT_DELETEfrom safedelete.managers import SafeDeleteManagerfrom safedelete.models import (    SafeDeleteModel)from django.utils import timezonefrom Functions.MyViews import RecStyleTitleFormat = RegexValidator(r'^[^\s]+$', 'spaces not allowed')# @Receiver(post_save, sender=settings.AUTH_USER_MODEL)# def create_auth_token(sender, instance=None, created=False, **kwargs):#     if created:#         Token.objects.create(user=instance)PHONE_NUMBER_REGEX = RegexValidator(    r'^[+]*[(]{0,1}[0-9]{1,4}[)]{0,1}[-\s\./0-9]*$', 'invalid phone number')USERNAME = RegexValidator(    r'^[a-zA-Z ]+$', 'only letter from a-z are allowed')REC = (    ('0 G day', 'Every day.'),)class Availability(SafeDeleteModel):    title = models.CharField(max_length=999, null=True, blank=True)    description = models.TextField(max_length=9999, blank=True, null=True)    start = models.DateTimeField(null=True)    end = models.DateTimeField(null=True)    from_time = models.TimeField(null=True, blank=True)    to_time = models.TimeField(null=True, blank=True)    date_created = models.DateTimeField(auto_now_add=True, null=True)    user = models.ForeignKey(settings.AUTH_USER_MODEL, related_name='availability', on_delete=models.CASCADE)    recurrence = Rec(blank=True, choices=REC)    class Meta:        get_latest_by = 'date_created'models_names = (('patient profile', 'patient profile'),)class Settings(SafeDeleteModel):    # Notifications settings/report settings    #    watch = models.CharField(max_length=50, choices=models_names, blank=True)    settings_type = models.CharField(max_length=999, choices=(        ('notifcations', 'notifcations settings'), ('reporet', 'reporet tashbord settings')), unique=True)    see_all = models.BooleanField(default=False)class Sex(models.Model):    name = models.CharField(max_length=50, blank=True)class UserManager(BaseUserManager, SafeDeleteManager):    def create_user(self, email, username, password, **kwargs):        now = timezone.localtime(timezone.now())        if not email:            raise ValueError('User must have an email address')        user = self.model\            (                email=self.normalize_email(email),                username=username,                password=password,                last_login=now, **kwargs)        user.set_password(password)        user.is_superuser = False        user.save(using=self._db)        return user    def create_superuser(self, email, username, password, **kwargs):        user = self.create_user(email=email, username=username, password=password)        user.is_active = True        user.is_staff = True        user.is_superuser = True        user.save(using=self._db)        return user    def get_by_natural_key(self, username_):        print(username_)        return self.get(username=username_)class User(SafeDeleteModel, AbstractUser, PermissionsMixin):    _safedelete_policy = SOFT_DELETE    import pytz    timezones = []    for tz in pytz.all_timezones:        zone = tz        # offset = pytz.timezone(tz).utcoffset(datetime.now())        # now = datetime.now(tz=pytz.UTC).astimezone(pytz.timezone(tz))        timezones.append((tz, tz))    timezone = models.CharField(choices=timezones, max_length=99, blank=True)    photo = models.ImageField(blank=True, null=True)    date_created = models.DateTimeField(auto_now=True, blank=True, null=True)    username = models.CharField(max_length=30, unique=True, validators=[USERNAME], blank=True)    #TODO todos and overtodos    # def todos(self):    #     for task in tasks:    #         if task.deadline <= now():    #             tasks_list.append(task)    email = models.EmailField(max_length=250, unique=True, blank=True)    secon_email = models.EmailField(max_length=250, blank=True)    # unique=True #TODO    sex = models.ManyToManyField(Sex, related_name='user_sex', blank=True)    first_name = models.CharField(max_length=999, blank=True, null=True)    last_name = models.CharField(max_length=999, blank=True, null=True)    middle_name = models.CharField(max_length=999, blank=True, null=True)    is_active = models.BooleanField(default=True)    is_staff = models.BooleanField(default=False)    is_superuser = models.BooleanField(default=False)    is_email_verified = models.BooleanField(default=False)    is_role_verified = models.BooleanField(default=False)    receive_newsletter = models.BooleanField(default=False)    birth_date = models.DateTimeField(blank=True, null=True)    # address = AddressField(related_name='+', blank=True, null=True)    city = models.CharField(max_length=999, blank=True, null=True)    about_me = models.TextField(max_length=500, blank=True, null=True)    phone_number = models.TextField(        max_length=500, blank=True, null=True, validators=[PHONE_NUMBER_REGEX])    second_phone_number = models.TextField(        max_length=500, blank=True, null=True, validators=[PHONE_NUMBER_REGEX])    imageUrl = models.CharField(max_length=900, blank=True, null=True)    # TODO if not availability then you can't create appointment    settings = models.ManyToManyField(Settings, related_name='who_can_see_comment', blank=True)    objects = UserManager()    USERNAME_FIELD = 'username'    REQUIRED_FIELDS = ['email', ]    class Meta:        get_latest_by = 'date_joined'class Address(SafeDeleteModel):    home = models.CharField(max_length=999, unique=True)    apt = models.CharField(max_length=999, unique=True)    state = models.CharField(max_length=999, unique=True)    zip_code = models.CharField(max_length=999, unique=True)    date_created = models.DateTimeField(auto_now_add=True)    user = models.OneToOneField(settings.AUTH_USER_MODEL, related_name='address', on_delete=models.SET_NULL, null=True,                                blank=True, unique=True)class Note(SafeDeleteModel):    title = models.CharField(max_length=200)    description = models.TextField(max_length=2000, null=True, blank=True)    alert_date = models.DateTimeField(help_text='specify time to remind you about this note', null=True, blank=True)    help_text = 'The users who will be notified. If empty the creator of the note wil notified if you specify users only the specified users will be notified and the creator will not be notified unless you included him/her'    users = models.ManyToManyField(settings.AUTH_USER_MODEL, related_name='notes', null=True,blank=True,help_text=help_text)